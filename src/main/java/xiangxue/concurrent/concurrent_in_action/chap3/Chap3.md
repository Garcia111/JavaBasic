并发编程实战第三章——————共享对象


   3.1.2非原子的64位操作
    Java存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位的读或写操作
    划分为两个32位的操作。如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现一个值的高
    32位和另一个值的低32位。因此long和double类型的数据读取到的可能不仅仅是一个过期的值，而有可能是一个错误的值。


   3.1.3锁和可见性
       内置锁可以用来确保一个线程以某种可以预见的方式看到另一个线程影响：
       线程A持有一把锁，执行一个同步块，线程B同样请求该锁，并且在线程B的同步块中会用到线程A同步块内的变量，
       当线程A执行一个同步块时，线程B也随后进入了被同一个锁监视的同步块中，这时可以保证，在锁释放之前，对线程A可见的
       变量的额值，B获得锁之后同样是可见的。
       换句话说，当B执行到与A相同的锁监视的同步块时，A在同步块中或之前所做的每件事，对线程B都是可见的，也就是保证了
       同步块内变量对两个线程的可见性。如果没有同步，就没有这样的保证。

   新认识：
   当访问一个共享的可变变量时，为什么要求所有线程由同一个锁进行同步，现在可以给出另一个理由：
       为了保证一个线程对数值进行的写入，其他线程也都可见。
       另一方面，如果一个线程在没有恰当地使用锁的情况下读取了变量，那么这个变量很可能是一个过期的数据。
       锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能看到共享的，可变变量的最新值，读取和写入线程
       必须使用公共的锁进行同步。


   3.1.4 Volatile变量
        1.当一个域声明为volatile类型后，编译器与运行时监视器会监视这个变量：它是共享的，并且对它的操作不会与其他的内存操作一起被重排序。
        2.volatile变量不会缓存在寄存器或者缓存在对其他处理器隐藏的地方。读一个colatile类型的变量时，总是会返回由某一个线程写入的最新值。
        3.访问volatile变量的操作不会加锁，也就不会引起执行线程的阻塞，这使得volatile变量相对于synchronized而言，只是轻量级的同步机制。

        正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的声明周期事件（比如初始化或关闭）的发生。
        volatile只确保变量的可见性，不确保同步。当同步策略复杂时，就不要使用volatile变量。

