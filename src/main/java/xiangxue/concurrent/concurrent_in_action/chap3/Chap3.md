并发编程实战第三章——————共享对象

3.1可见性

   3.1.2非原子的64位操作
    Java存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位的读或写操作
    划分为两个32位的操作。如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现一个值的高
    32位和另一个值的低32位。---因此long和double类型的数据读取到的可能不仅仅是一个过期的值，而有可能是一个错误的值。


   3.1.3锁和可见性
       内置锁可以用来确保一个线程以某种可以预见的方式看到另一个线程影响：
       线程A持有一把锁，执行一个同步块，线程B同样请求该锁，并且在线程B的同步块中会用到线程A同步块内的变量，
       当线程A执行一个同步块时，线程B也随后进入了被同一个锁监视的同步块中，这时可以保证，在锁释放之前，对线程A可见的
       变量的值，B获得锁之后同样是可见的。
       换句话说，当B执行到与A相同的锁监视的同步块时，A在同步块中或之前所做的每件事，对线程B都是可见的，也就是保证了
       锁控制的同步块内变量对持有同一个锁的两个线程的可见性。如果没有同步，就没有这样的保证。

   新认识：
   当访问一个共享的可变变量时，为什么要求所有线程由同一个锁进行同步，现在可以给出另一个理由：
       为了保证一个线程对数值进行的写入，其他线程也都可见。
       另一方面，如果一个线程在没有恰当地使用锁的情况下读取了变量，那么这个变量很可能是一个过期的数据。
       锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能看到共享的，可变变量的最新值，读取和写入线程
       必须使用公共的锁进行同步。


   3.1.4 Volatile变量
        1.【volatile变量的相关操作不会重排序】：当一个域声明为volatile类型后，编译器与运行时监视器会监视这个变量：它是共享的，并且对它的操作不会与其他的内存操作一起被重排序。
        2.volatile变量不会缓存在寄存器或者缓存在对其他处理器隐藏的地方。读一个volatile类型的变量时，总是会返回由某一个线程写入的最新值。
        3.访问volatile变量的操作不会加锁，也就不会引起执行线程的阻塞，这使得volatile变量相对于synchronized而言，只是轻量级的同步机制。
        4.加锁可以保证可见性与原子性，volatile变量只能保证可见性。

       正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的声明周期事件（比如初始化或关闭）的发生。
       volatile只确保变量的可见性，不确保同步。当同步策略复杂时，就不要使用volatile变量。

       volatile变量固然很方便，但是也存在限制，它们通常被当做标识完成、中断、状态的标记使用，判断volatile变量是否否和某个条件，然后执行
       某个操作。尽管volatile也可以用来标示其他类型的状态信息，但是决定这样做之前请格外小心，比如volatile的语义不足以使自增操作（count++）原子化，
       除非你能保证只有一个线程对变量执行写操作。


   只有满足了下面所有的标准后，才能使用volatile变量：
   1.写入变量时并不依赖变量当前的值，也就是不需要比较之后再赋值，直接赋值，只有一步操作；或者能够确保只有单一的线程修改变量的值；
   2.变量不需要与其他的状态变量共同参与不变约束

       例如下面的情景：
       volatile static int start = 3;
               volatile static int end = 6;

               线程A执行如下代码：
                   while (start < end){
                       //do something
                   }

               线程B执行如下代码：
               start+=3;
               end+=3;

               这种情况下，一旦在线程A的循环中线程B执行了，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。

   3.访问变量时，没有其他原因需要加锁，因为volatile保证的是对多个线程访问的可见性，如果加了锁，保证每次只能被一个线程访问，就没有使用volatile
     关键字的必要了。


3.2发布和逸出
    发布：发布一个对象的意思是试该对象能够被当前范围之外的代码所使用。
        比如，将一个引用存储到其他代码可以访问的地方；在一个非私有的方法中返回这个引用；将这个引用传递到其他类的方法中。
    逸出：一个对象在尚未准备好时就将它发布，这种情况称作逸出

    发布一个对象，同样也发布了该对象所有非私有引用链中的对象 和 方法调用链中可以获得的对象。

    假设有一个类C，从它的视角而言，一个外部方法的行为不是完全由C定义的。这包括在其他类中的方法和C自身可以被覆盖的方法。
    将一个对象传递给外部方法，相当于将这个对象发布了。因为实际上，你并不知道它会激发哪些代码，也不知道外部方法是发布这个对象，
    还是只保留它的引用，以供其他线程使用。















