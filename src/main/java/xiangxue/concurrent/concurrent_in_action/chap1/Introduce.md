介绍
    1.历史
        在发展初期，计算机还没有操作系统，它自始至终只是执行一个程序，这个程序直接访问机器的左右资源。每次
    只运行一个程序，不能很好地利用昂贵且稀缺的计算机资源。
        操作系统的发展使得多个程序能够同时运行，程序在各自的进程中运行，相互分离，各自独立执行，由操作系统
    分配资源，比如内存，文件句柄，安全证书。
        进程之间通过一些原始的机制相互通信：Socket、信号处理、共享内存、信号量和文件。线程允许程序控制流的
    多重分支同时存在于一个进程，多个线程共享进程范围内的资源，比如内存和文件句柄（？什么是文件句柄）,但是每一个线程
    都有其自己的程序计数器、栈和本地变量。同一个程序内多个线程可以在【多CPU】的情况下同时调度。

   多处理器的使用
       1.因为处理器很难再提高它的时钟频率，取而代之的是，处理器厂商会在一块芯片上防止更多的处理器内核。
       所有主要的芯片制造商都开始了这种转变，并且我们已经显著地看到机器中处理器数量的增加。
       2.程序调用的基本单元是线程，一个单线程应用程序一次只能运行在一个处理器上。在双处理器系统中，一个单线程程序，
        放弃了其中一半的空闲CPU；在拥有100个处理器的系统中，这个单线程放弃了99%的资源。拥有多个活跃线程的程序可以
        同时在多处理上运行，设计良好的情况下，多线程程序可以更有效地利用空闲处理器的资源，提高吞吐量。

   使用多线程也可以帮助我们在单处理器系统中实现更佳的吞吐量，如果一个程序是单线程的，这个处理器在等待一个同步I/O操作
   完成的时候，仍然是空闲的。使用多线程可以在一个线程等待I/O结束的同时，另一个线程也可以运行，这样就使得应用程序在
   遇到I/O阻塞的时候仍然有进展。

   使用@NotThreadSafe和@ThreadSafe Annotation标记类和类成员的线程安全与否对各类读者来说都是非常有用的，如果一个
   类标记为@ThreadSafe，用户就可以充满信心地将它应用于多线程环境；维护者则无需对此块代码进行线程安全维护；软件分析工具也可以
   转而去识别那些可能存在的代码错误。

   频繁地进行上下文切换会带来巨大的系统开销，保存和恢复线程执行的上下文，离开执行现场，并且CPU的时间会
   花在对线程的调度而不是运行上。当线程共享数据的时候，它们必须使用同步机制，这个机制会限制编译器的优化，
   能够清空或者锁定内存和高速缓存，并且在共享内存的总线上创建同步通信，所有这些因素又会引入新的性能开销。


   线程安全----一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为。

   无状态的对象永远是线程安全的。


   public class StatelessFactorizer implements Servlet{
        public void service(ServletRequest req, ServletResponse resp){
            BigInteger i = extractFromRequest(req);
            BigInteger[] factors = factor(i);
            encodeIntoResponse(resp,factors);
        }
   }

   StatelessFactorizer像大多数Servlet一样，是无状态的：既不包含域也没有引用其他类的域。
   一次特定计算的瞬时状态，会唯一地存在本地变量中，这些本地变量存储在线程的栈中，只有执行线程才能访问。
   一个访问StatelessFactorizer的线程，不会影响访问同一个Servlet的其他线程的计算结果，因为两个线程不共享
   状态，它们如同在访问不同的实例。
   因为线程访问无状态对象的行为，不会影响其他线程访问该对象时的正确性，所以无状态对象是线程安全的。

   竞争条件
   大多数的竞争条件的特点———使用潜在的过期观察值来作决策或者执行计算，这种竞争条件被称作检查再运行：
   观察到一些事情为真，然后基于观察去执行一些动作，但是事实上，从观察到执行操作的这段时间内，观察结果可能已经无效了，
   从而引发错误。

   原子性
   当其他线程想要查看或者修改一个状态时，必须在我们的线程开始之前或者完成之后，而不能在操作过程中。
   假设有操作A和B，如果从执行A的线程的角度看，当其他线程执行B时，要么B全部执行完成，要么一点都没有执行，这样A和B
   互为原子操作。


   2.3锁
   2.3.1内部锁
   Java提供了强制原子性的内置锁机制：synchronized块。
   【一个synchronized方法的锁就是该方法所在的对象本身，静态的synchronized方法从Class对象上获取锁】

        每个Java对象都可以隐式地扮演一个用于同步的锁的角色，这些内置的锁被称作内部锁或者监视器锁。执行
        线程进入synchronized块之前会自动获得锁，无论通过正常控制路径退出或者抛出异常退出，线程都会自动释放对
        synchronized块的控制锁。

        内置锁属于互斥锁
   互斥锁————至多只有一个线程可以拥有锁。

   2.3.2重入锁
    当一个线程请求其他线程已经占有的锁时，请求线程将会被阻塞，当线程试图获取它自己已经占有的锁时，请求会成功。
    重入锁的实现是为每个锁关联一个请求计数和一个占有它的线程，当计数器为0时，认为锁是未被占有的。
    当线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数置为1，如果同一个线程再次请求这个锁，计数将会递增；
    每次占用线程退出同步快，计数器将会递减，知道计数器达到0时，锁被释放。

    仅仅用synchronized块包装复合操作是不够的，虽然同步方法确保了不可分割操作的原子性，但是将多个操作整合到一个复合
    操作时，还是需要额外的锁。

  2.5活跃度与性能


