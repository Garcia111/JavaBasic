Chap5 构建快

5.1 同步容器
    同步容器类包含两部分：
    1.早期JDK的一部分：Vector和Hashtable；
    2.JDK1.2中加入的同步包装类，这些类是由Collections.synchronizedXxx工厂方法创建的。这些类通过封装其内部的状态，
     并对每一个公共方法进行同步而实现了线程安全。

  5.1.1 同步容器中出现的线程安全问题
      同步容器都是线程安全的，但是对于复合操作，有时你可能需要使用额外的客户端加锁进行保护。
      通常对容器的复合操作包括：
      1.迭代:反复获取元素，直到获得容器中的最后一个元素；
      2.导航：根据一定的顺序寻找下一个元素；
      3.条件运算：例如缺少即加入--必须如果缺少就加入，如果不缺少则不添加；

      for(int i=0; i<vector.size(); i++){
        doSomething(vector.get(i));
      }

  尽管vector是一个线程安全容器，但是上述代码仍然可能抛出异常，如果你在对Vector进行迭代的时候，另一个线程正在删除掉一个元素，
  并且这两个操作不巧交替发生了，那么这种迭代最终会抛出ArrayIndexOutOfBoundsException。抛出异常恰恰能够使Vector保持线程安全
  的规约一致性。



  5.1.2 迭代器和ConcurrentModificationException
      **对Collection进行迭代的标准方式是使用Iterator**，无论是显式地使用还是通过Java 5.0引入新的for-each循环语法，但是
      当有其他线程可能并发修改容器时，使用迭代器仍不可避免地需要在迭代期间对容器进行加锁。同步容器在迭代时并没有考虑到并发
      修改的问题，它们是fail-fast(“及时失败”也称作“快速失败”)的，当容器在迭代中被修改，会抛出一个未检查的ConcurrentModificationException。

      通过将修改计数器与容器关联起来实现的：如果在迭代期间计数器被修改，hasNext或者next会抛出一个ConcurrentModificationException，
      【这个检查是在没有同步的情况下进行的，所以存在一定风险，看到修改计数器上的过期数据，导致迭代器并没有发现修改。】

      为了避免出现ConcurrentModificationException，需要在迭代期间持有一个容器锁。

   迭代期间加锁的不便之处：

        当其他线程需要访问容器时，必须要等待，直到迭代结束，如果容器很大，或者对每一个元素执行的任务耗时比较长，其他线程可能需要等待很长
        一段时间。保持锁的时间越长，对锁的竞争就可能会越激烈，并且如果很多线程在等待锁的时候阻塞，吞吐量和CPU的效能都会受到影响。

   复制容器：
        在迭代期间，对容器加锁的一个替代办法是复制容器。？？复制是线程限制的，没有其他的线程能够在迭代期间对其进行修改（在单线程内部
        复制一个线程，复制的线程是只可线程内部访问的），这样消除了ConcurrentModificationException发生的可能性，
        容器仍然要在复制期间对自己加锁。复制容器会有明显的性能开销，这样做的好坏取决于许多因素，包括容器的大小，每一个元素的工作量、
        迭代器操作对于其他操作的频率，以及响应性和吞吐量的要求。

  5.1.3 **隐藏迭代器**
       **标准容器中的toString的实现会通过迭代容器中的每个元素，来获得关于容器内容**。例：

       public void addTenThings(){
            Random r = new Random();
            for(int i=0; i<10; i++){
                add(r.nextInt());
            }
            **System.out.println("DEBUG: added ten elements to "+set);**
       }

  上面的方法可能会抛出ConcurrentModificationException，因为隐藏迭代器不是线程安全的。
  【容器的hashCode和equals方法也会间接地调用迭代，比如当容器本身作为一个元素时，或者作为另一个容器的key时。
  类似地，containsAll removeAll retainAll方法，以及将容器作为参数的构造函数，都会对容器进行迭代，所有这些对迭代的
  间接调用都会引起ConcurrentModificationException】


5.2 并发容器
    同步容器：对容器的所有状态进行串行访问，从而实现了它们的线程安全；
            代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低。
    并发容器：是为多线程并发访问而设计的，Java5.0添加了ConcurrentHashMap,来代替同步的HashMap实现；
            CopyOnWriteArrayList是List相应的同步实现。
    用并发容器替换同步容器，使用很小的风险带来了可扩展性显著的提高。

        新的ConcurrentMap接口加入了对常见复合操作的支持，比如“缺少即加入(put-if-absent)”、替换和条件删除。


   >Queue的操作不会阻塞，如果队列是空的，那么从队列中获取元素的操作会返回null。
        如下为几种实现:
            ConcurrentLinkedQueue--传统的FIFO队列；
            PriorityQueue--一个非并发具有优先级顺序的队列；
   >BlockingQueue:扩展了Queue,增加了可阻塞的插入和获取操作，如果队列是空的，一个获取操作会一直阻塞直到队列中存在可用元素；
                如果队列是满的（对于有界队列），插入操作会一直阻塞直到队列中存在可用空间。

   ConcurrentHashMap是同步的哈希Map;
   **ConcurrentSkipListMap**：替代同步的SortedMap
   **ConcurrentSkipListSet**: 替代同步的SortedSet


   5.2.1 ConcurrentHashMap

   在一个哈希容器中，如果hashCode没有能很好地分散哈希值，元素很有可能不均衡地分布到整个容器中，最极端的情况是，一个不良的
   哈希函数将会把一个哈希表转化为一个线性链表。
   同步容器类在每个操作的执行期间都持有一个锁，有一些操作，比如HashMap.get或者List.contains，可能会涉及到比预想更多的
   工作量：为寻找一个特定对象而遍访整个哈希容器或者清单，必须调用大量候选对象的equals，比对元素的hashCode，这会花费很长
   时间，并且在这段时间内，其他线程都不能访问这个容器。

   ConcurrentHashMap使用完全不同的锁策略：
   >同步Map:提供的是为独占的访问加锁，程序使用一个公共锁同步每一个方法，并严格地限制只能一个线程可以同时访问容器。
   >ConcurrentHashMap:使用一个更加细化的锁机制，称为**分离锁**。
                                    分离锁机制允许更深层次的共享访问:
                                    1.任意数量的读线程可以并发访问Map;
                                    2.读者和写者可以并发访问Map;
                                    3.有限数量的写线程还可以并发修改Map
                                    为并发访问带来更高的吞吐量，同时几乎没有损失单个线程访问的性能
       ConcurrentHashMap的迭代器：
                    提供不会抛出ConcurrentModificationException的迭代器，因此不需要在容器迭代中加锁。
                    ConcurrentHashMap的迭代器具有弱一致性，弱一致性的迭代器可以容许并发修改，------什么是弱一致性？
                    当迭代器被创建时，它会遍历已有的元素，并且可以感应到在迭代器被创建后线程对容器的修改。

   并发容器的size和isEmpty在计算的时候可能已经过期，允许size返回一个近似值而不是一个精确值。事实上，size和isEmpty
   这样的方法在并发环境下几乎没有什么用处。

   相比与同步容器Hashtable和synchronizedMap，并发容器ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势。
   在大多数情况下用ConcurrentHashMap取代同步Map实现智慧带来更好的可伸缩性。只有当程序需要在独占访问中加锁时，
   ConcurrentHashMap才无法胜任。


   5.2.2 Map附加的原子操作
        因为ConcurrentHashMap不能够在独占访问中被加锁，我们不能使用客户端加锁来创建新的原子操作。

   5.2.3 CopyOnWriteArrayList
        CopyOnWriteArrayList是同步List的一个并发替代品，通常情况下它提供了更好的并发性，并避免了在迭代期间对容器加锁和复制。
        类似的CopyOnWriteArraySet是同步Set的一个并发替代品。
     "copy-on-write"容器的线程安全性是如何保证的：------简单来说就是在需要修改容器内容时复制容器，所以叫copy on write

        只要有效的不可变对象被正确发布，访问它将不再需要更多的同步。在每次需要修改时，它们会创建并重新发布一个新的容器拷贝，以此
        来实现可变性。多个线程可以对这个容器进行迭代，不会造成并发修改错误。“写入时复制”容器返回的迭代器不会抛出
        ConcurrentModificationException，并且返回的元素严格与迭代器创建时一致，不会考虑后续的修改。

          每次容器改变时复制基础数组需要一定的开销，特别是当容器比较大的时候。

     【当对容器迭代操作的频率原高于对容器修改的频率时，使用"写入时复制"容器是个合理的选择。】
     例子：
     向监听器列表递交一个通知，对已经注册的监听器列表进行迭代，并调用其中每一个。在多数情况下，注册和注销一个事件监听器的次数要比收到事件
     通知的次数少很多。也就是对事件监听器列表修改要远少于对该列表的迭代次数，因此此种情况下使用CopyOnWriteArrayList比较合适。


5.3 阻塞队列和生产者-消费者模式
        阻塞队列支持生产者-消费者模式，

        BlockingQueue的实现：
        1.LinkedBlockingQueue
        2.ArrayBlockingQueue
        3.PriorityBlockingQueue
        4.SynchronousQueue
            【SynchronousQueue根本上不是一个真正的队列，因为它不会为队列元素维护任何存储空间。】
            它维护一个排队的线程清单，这些线程等待将元素加入队列或者移出队列。
            在洗盘子的比喻中，好比没有盘子架，却把洗好的盘子直接放入下一步的空闲烘干机。也就是直接将任务交给消费者，而不是放入一个消费
            队列内，等待消费者来取。
            这种实现队列的方式，减少了在生产者和消费者之间移动数据的延迟时间。直接地移交同样会给生产者带来更多关于任务状态的反馈信息：
            当移交被接受，它就知道消费者已经得到了任务，而不是简单地将任务放在一个队列中。
            因为SynchronousQueue没有存储能力，所以除非另一个线程已经准备好参与移交工作，否则put和take会一直阻塞。
            【SynchronousQueue这类队列只有在消费者充足的时候比较合适，它们总能为下一个任务做好准备。】

 5.3.2 连续的线程限制

    在java.util.concurrent 中实现的阻塞队列，全部都包含充分的【内部同步】，从而能安全地将对象从生产者线程发布至消费者线程。

   对于可变对象，生产者-消费者设计和阻塞队列一起，为生产者和消费者之间移交对象所有权提供了连续的线程限制。一个线程约束的
   对象完全由单一线程所有，但是所有权可以通过安全的发布被“转移”，这样其他线程中只有唯一一个能够的得到访问这个对象的权限，
   并且保证移交之后原线程不能再访问它。


 5.3.3 **双端队列和窃取工作**
        双端队列，基类：**Deque**，允许高效地在头和尾分别进行插入和移除，实现类为**ArrayDeque**和**LinkedBlockingQueue**。

   窃取工作模式：
    在窃取工作的设计中，每一个消费者都有一个自己的双端队列。如果一个消费者完成了自己双端队列中的全部工作，它可以偷取其他消费者
    的双端队列中的末尾任务。大多数时候消费者访问自己的双端队列，减少竞争。当一个消费者必须要访问另一个队列时，它会从尾部截取，而不是
    从头部，从而进一步降低对双端队列的争夺。


5.4 阻塞和可中断的方法
   线程可能会因为几种原因被阻塞或者暂停：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep中唤醒，或者是另外一个线程
   的计算结果。当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态（BLOCKED WAITING 或是 TIMED_WAITING）。

    Thread提供了interrupt方法，用来终端一个线程或者查询线程是否已经被中断。每一个新线程都有一个代表线程中断状态的布尔值，
    中断线程时需要这个值。


   如何响应中断异常InterruptedException：
   1.传递：直接不捕获InterruptedException，而是传递给你的代码的调用者，也可能是捕获之后，进行某个操作，然后继续将异常抛出；
           但是不应捕获异常，但是不做任何响应，这样做会丢失线程中断的证据，从而剥夺了上层栈的代码处理中断的机会。
   2.恢复中断：
     有时候是不能抛出InterruptedException的，比如当你的代码是Runnable的一部分时。在此种情况下，你必须捕获InterruptedException，
     【**并且，在当前线程中通过调用interrupt从中断中恢复？？？**】这样调用栈中更高层的代码可以发现中断已经发生。


     ？？？
     public class TaskRunnable implements Runnable{

          BlockingQueue<Task> queue;

          ...

          public void run(){
            try{
                processTask(queue.take());
            }catch(InterruptedException e){
                //恢复中断状态
                Thread.currentThread().interrupt();
            }
          }
     }


5.5 Synchronizer
    阻塞队列在容器类中是独一无二的：它们不仅作为对象的容器，而且能够协调生产者线程和消费者线程之间的控制流，这是因为take和
    put会保持组织状态知道队列进入了期望的状态（不空也不满）。

    Synchronizer是一个对象，它根据本身的状态调节线程的控制流。
    阻塞队列是Synchronizer的一种，其他类型的Synchronizer包括信号量（semaphore）、关卡(barrier)
    以及闭锁(latch)。

    Synchronizer具有的结构特性：
    封装状态，这些状态决定着线程执行到某一点时是通过还是被迫等待；
    提供操控状态的方法，以及高效地等待Synchronizer进入到期望状态的方法。


 【5.5.1 闭锁】
    闭锁是一种Synchronizer，可以用来确保特定活动直到其他活动完成之后才发生。
    闭锁的生动比喻：
    一个闭锁工作起来就像是一道大门，直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，
    允许所有线程都通过。一旦闭锁到达了终点状态，它就不能再改变状态了，会永远保持敞开状态。


    示例：
    1.确保一个计算不会执行，直到它需要的资源被初始化，否则所有需要用到该资源的活动都需要在闭锁中等待。
    2.确保一个服务不会开始，直到它依赖的其他服务都已经开始。
    3.好比有一个核弹，但是密码是由三个人各自保管一部分，只有三个人全部到齐，才能凑出完整的密码，引爆核弹。

    CountDownLatch:
    1.包含一个计数器，初始化为一个正数，用来表现需要等待的事件数；
    2.CountDown方法对计数器锁减一操作
    3.await 等待计数器减至为0时，此时所有需要等待的事件都已经发生，也就是三个持有密码的人全部到场了
    其他解释见thread.md 实例见CountDownLatchDemo.java  TestHarness.java


 【5.5.2 FutureTask】
     FutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable，并且有3个状态：等待、运行和完成。完成包括
     所有计算以任意的方式结束，包括正常结束、取消和异常。

     Future.get的行为依赖于任务的状态，如果它已经完成，get可以立刻得到返回结果，否则会被阻塞直到任务转入完成状态，然后会
     返回结果或者抛出异常。

  新认识：【**FutureTask将计算的结果从运行计算的线程传送到需要这个结果的线程，FutureTask的规约保证了这种传递的
            建立在结果的安全发布基础之上。**】

     Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时计算，而且可以在真正需要计算结果之前就启动它们
     开始计算。示例见：Preloader.java


 【5.5.3 信号量 Counting semaphore】
    计数信号量用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。

    计数器信号量可以用来实现资源池或者给一个容器限定边界。

   一个信号量管理一个有效的许可集，许可的初始量通过构造函数传递给Semaphore；许可的初始量通过构造函数传递。
   只要还有剩余许可，活动就能够通过acquire获得许可，并在使用之后通过release方法释放许可。
   如果已经没有可用的许可，acquire会被阻塞，直到有可用的为止，或者直到被中断或者操作超时。
   一个线程得到的许可，可能是其他线程释放的。

   二元信号量
   是一个计数初始值为1的信号量，二元信号量可用作互斥锁，它有不可重入锁的语义，谁拥有这个唯一的许可，就拥有了互斥锁。

   使用信号量来实现实现资源池
   以池的大小初始化一个Semaphore，在从池中获取资源之前，应该调用acquire方法获取一个许可，调用release将许可放回资源池。


   使用信号量将容器转化为有界的阻塞容器 示例：BoundedHashSet.java


 【5.5.4】关卡 CyclicBarrier
    关卡与闭锁
    相同点：都能阻塞一组线程，知道某些事件发生；
    不同点：所有线程必须同时到达关卡点，才能继续处理，闭锁等待的是事件，而关卡等待的是其他线程

    关卡在并行迭代算法中非常有用
    这个算法将一个问题拆分成一系列相互独立的子问题，当线程到达关卡点时，调用await方法，await会被阻塞，直到所有线程都到达关卡点。
    如果所有线程都到达了关卡点，关卡就会被成功地突破，这样所有的线程都会被释放，关卡会重置以备下一次使用。

  新认识：
    1.如果对await的调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有对await未完成的调用都通过BrokenBarrierException终止。
    2.如果成功地通过关卡，await为每一个线程返回一个唯一的到达索引号。可以用它来“选举”产生一个领导，在下一次迭代中承担一些特殊的工作。
    3.CyclicBarrier允许你向构造函数传递一个Runnable任务作为关卡行为，当线程成功通过关卡的时候，此任务会在一个子任务中执行，
      但是在阻塞线程被释放之前是不能执行的。
















