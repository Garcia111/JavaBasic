并发
   1.使用Runnable接口定义任务
    线程可以驱动任务，这可以由Runnable接口来提供。
    任务的run方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件。
    通常，run()将会被写成无限循环的形式，这就意味着，除非有某个条件使得run()终止，否则它将永远运行下去。
    
    调用Thread.yield()-----当前线程的当前任务已经完成，CPU可以切换给其他任务执行一段时间。
    要实现线程行为，必须显示地将一个任务附着到线程上。
    
    
  2.Thread类
    将Runnable对象转换为现成的方式是将其提交给一个Thread构造器。
    如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发线程。
    
    在main()创建Thread对象时，它并没有捕获任何对这些对象的引用。Thread对象的引用与普通对象的引用不同，
    每个Thread对象都注册了它自己，因此它自己存在一个对它的引用，而且在该线程的任务退出其run()方法并死亡之前，
    垃圾回收期都无法清除它。因此，一个线程会创建一个单独的执行线程，在对start()的调用完成之后，
    它仍旧会继续存在。
    
  
  3.使用Executor
    Java.util.concurrent包中的执行器Executor将为你管理Thread对象，Executor在客户端和任务执行之间提供了一个
    间接层，与客户端直接执行任务不同，这个中介对象将执行任务。Executor允许你管理异步任务的执行，而无须显示地管理线程的
    生命周期。
    【命令设计模式】
     shudown()方法-----可以防止新的任务被提交给这个Executor，当前线程将继续运行在shutdown()被调用
     之前提交的所有任务。当调用了shutdown方法之后，即使再给ExecutorService添加新的任务，也不会再
     继续创建新的线程来执行此新的任务。
     
     使用FixedThreadPool
     可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量了。
     这样可以节省时间，因为你不用为每个任务都固定地付出创建线程的开销。？？？
     
     使用CachedThreadPool
     CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，
     然后在它回收旧线程时停止创建新线程。
     
     使用SingleThreadExecutor
     SingleThreadExecutor就像是线程数量为1的FixedThreadPool。
     如果像SingleThreadExecutor提交了多个任务，那么这些任务将会排队，
     每个任务都会在下一个任务开始之前运行结束，所有的任务将会使用相同的线程。
     SingleThreadExecutor会序列化所有提交给它的任务，并且会维护它自己的悬挂任务队列。
     
     
     
   4.Callable 从任务中返回值
    Runnable是执行工作的独立任务，但是它不会返回任何值，执行完完事儿。
    使用Callable接口，可以在任务完成时返回一个值。
    Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中返回的值，并且
    必须使用ExecutorService.submit()方法调用call()方法。
    
    Submi()的Future结果对象
    submit()方法会产生Future对象，用Callable返回结果的特定类型进行了参数化。
    可以使用isDone()来查询Future是否已经完成，当任务完成时，Future对象会具有一个结果，可以调用get()来获取这个结果。
    如果你不用isDone()进行检查，就直接调用get()，这种情况下，get()将会阻塞，直至结果准备就绪。
    
    //todo 这块需要更多的理解和练习
    
  5.休眠 sleep()
  sleep()方法将使任务中止执行给定的时间。对sleep()的调用可能跑出InterruptedException
  
  
    【如果你必须控制任务执行的顺序，那么最好的押宝就是使用同步控制，或者在某些情况下，压根不使用线程，
    但是要编写自己的协作例程，这些例程将会按照指定的顺序在相互之间传递控制权】？？
    
  6.优先级
    线程的优先级将该线程的重要性传递给了调度器。
    尽管CPU处理现有线程集的顺序是不确定的，但是调度器倾向于让优先权最高的线程优先执行。
    优先级较低的线程执行的频率较低。
    【在绝大多数时间里，所有的线程都应该以默认的优先级运行。试图操纵线程优先级通常是一种错误】
    
    最常用的有MAX_PRIORITY  NORM_PRIORITY 和MIN_PRIORITY三种级别。
   
  7.yield()让步
    调用yield()方法意味着，知道run()已经完成的差不多了，按时可以让别的线程使用CPU了，
    这个暗示由yield()发出，【这仅仅是一个暗示，没有任何机制保证它将会被采纳】。
    当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。
    
    值得注意的是yield()经常被误用。 
    
  8.后台线程
    后台线程是指在程序运行的时候提供一种通用服务的线程，并且这种线程不属于程序中不可或缺的部分。
    当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。
    反过来说，只要有任何非后台线程还在运行，程序就不会终止。
    没有了守护的人，守护线程也就默默死去了，呜呜呜~~~
    
    如果一个线程是后台线程，那么它创建的任何线程将会被自动设置成后台线程,即使这些被创建的线程没有被显式地使用setDaemon()设置为守护线程。
    【后台进程在不执行finally子句的情况下就会终止run()方法。】
    
    //todo 修改SimplePriorities，使得定制的ThreadFactory可以设置线程的优先级。
    
  9.加入一个线程
    一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才能继续执行。
    相当于插队，如果某个线程在另外一个线程t上调用t.join()，此线程将会被挂起，直到目标线程t结束才恢复。
    
    也可以在调用join()时带上一个超时参数（毫秒 纳秒），这样如果目标线程在这段时间到期时还没有结束的话，
    join()方法总是能够返回。
    
    对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch子句。
   
  
  10.捕获异常
   
       线程中的异常会逃出异常，使用普通的try catch方式无法捕获异常。
       Thread.UncaughtExceptionHandler是Java SE5中的接口，它允许你在每一个Thread对象上
       都附着上一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程
       因未捕获的异常而临近死亡的时候被调用。
       
       实例：CaptureUncaughtException.java
    
       如果线程中抛出的异常，使用的相同的异常处理器，可以在Thread类中设置一个静态域，并将这个处理器设置为
       默认的未捕获异常处理器。
       
       public class SettingDefaultHandler {
       
           public static void main(String[] args){
               Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
               ExecutorService exec = Executors.newCachedThreadPool();
               exec.execute(new ExceptionThread());
               //设置ExceptionThread类的默认异常处理器为MyUncaughtExceptionHandler
           }
       }
       
       
       这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。
       系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，
       如果也没有，再调用defaultUncaughtExceptionHandler。
       
       
  11.共享资源
        
        通过将线程要执行的任务与线程需要访问的共享资源进行分离，这可以消除所谓竞争条件，即两个或者更多的任务
        竞争响应某个条件，因此产生冲突或者不一致结果的情况。
        需要仔细考虑并防范并发系统失败的所有可能途径，例如：
        一个任务不能依赖于另一个任务，因为任务关闭的顺序无法得到保证。这里，通过使用任务以来与非任务对象，
        我们可以消除潜在的竞争条件。    
    
        基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案，
        这意味着给定时刻只允许一个任务访问共享资源。
        
        共享资源一般是以对象形式存在的内存片段，但是可以使文件、输入/输出端口，或者是打印机。
        要控制对共享资源的访问，需要先将其包装进一个对象，然后将所有要访问这个资源的方法标记为synchronized，
        这样对该共享资源的访问就可以使用锁来控制。
        
        注意：被锁住的共享资源域变量需要设置为private。
        
        一个任务对同一个资源锁住多次----可重入锁：
            一个任务可以多次获得对象的额锁，如果方法m1在加锁对象Object上调用了m2，m2同样又调用了该加锁对象上的m3方法
            会导致对同一个对象加多次锁。
    
            JVM负责跟踪对象被加锁的次数，如果一个对象被解锁，即锁别完全释放，其计数变为0；在任务第一次给对象加锁的时候，
            计数变为1；每当这个相同的任务在这个对象上获得锁时，技术都会递增。只有首先获得了锁的任务才能允许继续获得多个锁。
            每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
    
  12.使用显示的Lock对象
   
     使用显式Lock对象与使用synchronized关键字的区别：
      1.使用synchronized关键字时，如果某些事物失败了，就会抛出一个异常，但是你没有机会去做任何清理工作，
        以维护系统使其处于良好状态。
        使用显式的Lock对象，可以使用finally子句将系统维护在正确的状态。
      
        public int next() {
        lock.lock();
        try{
           ++currentEventValue;
           Thread.yield();
           ++currentEventValue;
           //注意 return语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给第二个任务
           return currentEventValue;
        }finally {
            lock.unlock();
        }
      
      2.一般只有在解决特殊问题时，才会使用显式的Lock对象。例如，使用sychronized关键字不能实现，尝试着获取锁，
      并且最终获取锁失败。或者尝试着获取锁一段时间，如果没有获取到则放弃它。
      
      ReentrantLock允许你尝试着获取但是最终未获取到锁，这样如果其他人已经获取到了这个锁，你就可以决定离开去执行一些其他事情，
      而不是直至这个锁被释放。
      
      示例：AttemptLocking.java
    
      3.显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更细粒度的控制力。
      
      //todo 了解ReentrantLock
      
      
  13.原子性与易变性
      原子性
       
        原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在线程切换之前完成。
        
        原子性可以应用于除long和double之外的所有基本类型上的简单操作，JVM可以将这些操作当做原子性的操作来操作内存。
        但是JVM可以将64位（long和double）的读取和写入当做两个分离的32位操作来执行，这就产生了一个读取和写入操作中间
        发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性。
        当你定义long或者double变量时，如果使用volatile关键字修饰变量，则变量的简单赋值与读取操作就具有了原子性。
        
   可视性
        
        一个任务作出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的，例如，修改只是暂时性地存储
        在本地处理器的缓存中，因此不同的任务对应用的状态有不同的视图。
    
        【**volatile关键字确保了应用中的可视性，如果你将一个域声明为volatile的，那么只要是对这个域产生了写操作，那么所有的
        读操作就可看到这个修改。即使使用了本地缓存，volatile修饰的域就会被立即写入到主存中，而读取操作就发生在主存中。**】
    
        在非volatile域上的原子操作不必刷新到主存中去，其他读取该域的任务也不必看到这个新值。
        1.如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则这个域就应该只能经由同步来访问。因此，如果一个域
        完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。
        2.一个任务所作的任何写入操作对这个任务来说都是可视的，因此如果它只是需要在这个任务内部可视，那么你就不需要将其设置为volatile。
        3.当一个域的值依赖于它之前的值时，volatile就无法工作了；
        4.如果某个域的值受到其他域的值的限制，那么volatile也无法工作，例如Range类的lower和upper边界，就必须遵循lower<=upper的限制。
        5.使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。
        
  14.原子类
        Java SE5中引入了AtomicInteger AtomicLong AtomicReference等特殊的原子性变量类，
        Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用它们，即便是使用了也需要确保不存在其他
        可能出现的问题。通常依赖于锁要更安全一些（要么是synchronized关键字，要么是显式的Lock对象）。
        
  15.临界区
        
        使用synchronized关键字来建立临界区，synchronized被用来指定某个对象，此对象的锁被用来对花括号内部的代码进行同步控制。
        synchronized(syncObject){
        
        }
        进入同步代码块之前，需要得到syncObject对象的锁，如果其他线程已经得到这个锁，就得等到锁被释放以后，才能进入临界区。     
      
        【Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的
        代码中使用它们，即便使用了也需要确保不存在其他可能出现的问题。通常依赖于锁要更安全一些，
        要么是synchronized关键字，要么是显式的Lock对象。】    
        
        
  15.临界区
    有时，只是希望多个线程同时访问方法内部的部分代码而不是防止访问整个方法，通过这种方式分离出来的代码
    称为临界区。
    
    synchronized(syncObject){
    
    }
     
    
    
    
    
      
    
    
    
       
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
       
    