并发
    1.使用Runnable接口定义任务
    线程可以驱动任务，这可以由Runnable接口来提供。
    任务的run方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件。
    通常，run()将会被写成无限循环的形式，这就意味着，除非有某个条件使得run()终止，否则它将永远运行下去。
    
    调用Thread.yield()-----当前线程的当前任务已经完成，CPU可以切换给其他任务执行一段时间。
    
    要实现线程行为，必须显示地将一个任务附着到线程上。
    
    
  2.Thread类
    将Runnable对象转换为现成的方式是将其提交给一个Thread构造器。
    如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发线程。
    
    在main()创建Thread对象时，它并没有捕获任何对这些对象的引用。Thread对象的引用与普通对象的引用不同，
    每个Thread对象都注册了它自己，因此它自己存在一个对它的引用，而且在该线程的任务退出其run()方法并死亡之前，
    垃圾回收期都无法清除它。因此，一个线程会创建一个单独的执行线程，在对start()的调用完成之后，
    它仍旧会继续存在。
    
  
  3.使用Executor
    Java.util.concurrent包中的执行器Executor将为你管理Thread对象，Executor在客户端和任务执行之间提供了一个
    间接层，与客户端直接执行任务不同，这个中介对象将执行任务。Executor允许你管理异步任务的执行，而无须显示地管理线程的
    生命周期。
    【命令设计模式】
     shudown()方法-----可以防止新的任务被提交给这个Executor，当前线程将继续运行在shutdown()被调用
     之前提交的所有任务。当调用了shutdown方法之后，即使再给ExecutorService添加新的任务，也不会再
     继续创建新的线程来执行此新的任务。
     
     使用FixedThreadPool
     可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量了。
     这样可以节省时间，因为你不用为每个任务都固定地付出创建线程的开销。？？？
     
     使用CachedThreadPool
     CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，
     然后在它回收旧线程时停止创建新线程。
     
     使用SingleThreadExecutor
     SingleThreadExecutor就像是线程数量为1的FixedThreadPool。
     如果像SingleThreadExecutor提交了多个任务，那么这些任务将会排队，
     每个任务都会在下一个任务开始之前运行结束，所有的任务将会使用相同的线程。
     SingleThreadExecutor会序列化所有提交给它的任务，并且会维护它自己的悬挂任务队列。
     
     
     
   4.Callable 从任务中返回值
    Runnable是执行工作的独立任务，但是它不会返回任何值，执行完完事儿。
    使用Callable接口，可以在任务完成时返回一个值。
    Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中返回的值，并且
    必须使用ExecutorService.submit()方法调用call()方法。
    
    Submi()的Future结果对象
    submit()方法会产生Future对象，用Callable返回结果的特定类型进行了参数化。
    可以使用isDone()来查询Future是否已经完成，当任务完成时，Future对象会具有一个结果，可以调用get()来获取这个结果。
    如果你不用isDone()进行检查，就直接调用get()，这种情况下，get()将会阻塞，直至结果准备就绪。
    
    //todo 这块需要更多的理解和练习
    
  5.休眠 sleep()
  sleep()方法将使任务中止执行给定的时间。对sleep()的调用可能跑出InterruptedException
  
  
    【如果你必须控制任务执行的顺序，那么最好的押宝就是使用同步控制，或者在某些情况下，压根不使用线程，
    但是要编写自己的协作例程，这些例程将会按照指定的顺序在相互之间传递控制权】？？
    
  6.优先级
    线程的优先级将该线程的重要性传递给了调度器。
    尽管CPU处理现有线程集的顺序是不确定的，但是调度器倾向于让优先权最高的线程优先执行。
    优先级较低的线程执行的频率较低。
    【在绝大多数时间里，所有的线程都应该以默认的优先级运行。试图操纵线程优先级通常是一种错误】
    
    最常用的有MAX_PRIORITY  NORM_PRIORITY 和MIN_PRIORITY三种级别。
   
  7.yield()让步
    调用yield()方法意味着，知道run()已经完成的差不多了，按时可以让别的线程使用CPU了，
    这个暗示由yield()发出，【这仅仅是一个暗示，没有任何机制保证它将会被采纳】。
    当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。
    
    值得注意的是yield()经常被误用。 
    
  8.后台线程
    后台线程是指在程序运行的时候提供一种通用服务的线程，并且这种线程不属于程序中不可或缺的部分。
    当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。
    反过来说，只要有任何非后台线程还在运行，程序就不会终止。
    没有了守护的人，守护线程也就默默死去了，呜呜呜~~~
    
    如果一个线程是后台线程，那么它创建的任何线程将会被自动设置成后台线程,即使这些被创建的线程没有被显式地使用setDaemon()设置为守护线程。
    【后台进程在不执行finally子句的情况下就会终止run()方法。】
    
    //todo 修改SimplePriorities，使得定制的ThreadFactory可以设置线程的优先级。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      
    
    
    
       
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
       
    