阻塞队列
    同步队列在任何时刻都只允许一个任务插入或者移除元素。如果消费者任务试图从队列中获取对象，
    而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素时可以恢复消费者任务,不需要我们编写代码去唤醒。
    
   几种主要的阻塞队列
   ArrayBlockingQueue（基于数组的，默认非公平的）:
     
        基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须指定容量大小，并且可以指定公平性和非公平性，
        **默认情况下为非公平的**，即不保证等待最长的线程能够最优先访问队列。
         
   LinkedBlockingQueue（基于链表实现）:
     
        基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则**默认大小为Integer.MAX_VALUE**
        
   PriorityBlockingQueue(无界，非先进先出):
   
        以上两种队列都是FIFO队列，而PriorityBlockingQueue却不是，它会按照元素的优先级别对元素进行排序，按照优先级顺序出队。
        每次出队的元素都是优先级别最高的元素，注意，此阻塞队列为无界阻塞队列，即容量没有上线，前两种都是有界队列。
        
   DelayQueue:
   
        基于PriorityQueue，是一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能从队列中获取该元素。
        DelayQueue也是有一个无界队列，因此向队列中插入数据的生产者永远不会被阻塞，而只有获取数据的消费者才会被阻塞。
    
    
   阻塞队列中的方法
   
        以下5个方法在非阻塞队列中也存在：
            1.add(E e):将元素e插入到队列末尾，如果插入成功，则返回true;插入失败，抛出异常；
            2.remove():移除队首元素，若是移除成功，则返回true;若是移除失败，则抛出异常；
            3.offer(E e):将元素e插入到队列末尾，如果插入成功，返回true;若是插入失败(即队列已满)，则返回false
            4.poll():移除并获取队首元素，若是成功，则返回队首元素，否则返回null
            5.peek()：获取而不移除队首元素，成功返回元素，否则返回null.
            
            对于非阻塞队列，一般情况下建议使用offer poll peek三个方法，不建议使用add remove方法，因为使用offer pool peek三个方法可以
            通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。
            
            以上5个方法在阻塞队列和非阻塞队列中都存在，不同的是在非阻塞队列中没有进行同步，而在阻塞队列中进行了同步。
            
            阻塞队列同时还包含下面4个非常有用的方法：
            1，put(E e)
                向队尾存入元素，如果队列满了，则等待；
            2.take()
                从队首取出元素，如果队列为空，则等待；
            3.offer(E e,long timeout,TimeUnit unit)
                向队尾存入元素，如果队列满了，则等待一定的时间，当时间期限达到时，如果还没有插入成功，返回false，否则返回true
            4.poll(long timeout, TimeUnit unit)
                从队首取出元素，如果队列为空，则等待一定的时间，当时间期限达到时，如果取到，返回取到的元素，否则返回null。
            
            
   阻塞队列的实现原理
        
        //todo 实现自己的ArrayBlockingQueue
        
                
            
            
            
            
            
            
            
            
            