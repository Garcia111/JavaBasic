redis缓存穿透和缓存击穿

使用缓存主要是为了提升性能和保护数据库，减少查询数据库的频率。  

缓存穿透
    重点在一个透字，指的是查询的时候，数据库库中没有数据，缓存中也没有数据
    
缓存击穿
    数据库里面有，但是缓存当中没有，当查询的时候会先查询缓存，
    问题：高并发情况下，多个请求会同时发现缓存当中没有，会同时去查询数据库，造成数据库压力过大。
    

常规的查询缓存的方式：
    首先查询缓存，缓存命中，则返回；
               缓存未命中，查询数据库，数据库命中则返回
                                   数据库未命中，则返回查询无果；
引起的问题：缓存击穿和缓存穿透
解决问题1：缓存穿透，查询不存在的数据，解决方案有两个：
    1.缓存空对象：即使数据库库中不存在该数据，在缓存中加一个空对象记录，
    当该key对应的请求第二次查询的时候，在缓存当中会返回该空对象。
    缺点：治标不治本
    2.使用布隆过滤器：Guava有封装好的布隆过滤器
    引入依赖
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>25.1-jre</version>
        </dependency>
                              
   如何使用布隆过滤器解决缓存穿透？
   
        将key值全部加入到布隆过滤器中，如果布隆过滤器中存在值，则放行；否则直接返回数据库不存在。
   
   布隆过滤器原理：
   
        3个hash函数（hash函数个数与设定的误判率有关，不一定为3，这里只是举个例子），将key对象进行hashCode，
        然后再针对数组的长度进行取余，然后取得3个下标，将下标对应的元素改为1。
        从布隆过滤器当中取值时，也是使用3个hash函数，将key对象进行hashCode,然后针对数组长度进行取余，查看3个下标对应的元素
        是否为1，如果为1则表明该key值对应的value，在数据库中可能存在，则放行。
        因为使用布隆过滤器存储的仅仅是key值，而不是整个对象，所以非常节省内存空间。 
        
        误差率：与数组长度有关（hashCode完之后要取余），数组长度越大，误差率越小，但是同时占用内存也越多（数组是自动扩容的）；
                与hash函数的个数有关，hash函数越多，则误差的概率越小。
        
        布隆过滤器的缺陷：
                1.不能删除值，当数据库中某个值删除之后，布隆过滤器中该key对应的hash值是不能删除的；
                2.布隆过滤器中存储的是真实值的映射信息，只能判断该值是否存在，而不能从布隆过滤器中取出该值。
                
        redis底层保存的值是该值的二进制数据。
            127.0.0.1:6379> set cheng abc
            OK
            127.0.0.1:6379> setbit cheng 6 1
            (integer) 0
            127.0.0.1:6379> setbit cheng 7 0
            (integer) 1
            127.0.0.1:6379> get cheng
            "bbc"
            
            abc的二进制形式为：1100001 1100010 1100011
            setbit cheng 6 1的意思为为将key cheng对应的值的第六位改为1
            setbit cheng 7 0的意思为为将key cheng对应的值的第七位改为0
            
            
            创建数组：setbit array 50000000000 0 ------创建了一个长度为50000000000的数组
            布隆过滤器底层对数组的操作就是使用setbit和getbit来进行位操作，因此占用内存是非常小的
            布隆过滤器存储一个key的时候，就是使用setbit命令将数组某个下标的元素置为1；
            判断一个key值是否在数据库中存在时候，就是使用getbit命令取出数组中某个下标的元素是否为1。
            
            自己使用Redis 实现布隆过滤器，与使用Guava自带的布隆过滤器的区别：
            使用Guava布隆过滤器，会有分布式的问题
            
            
缓存击穿解决：
    查询数据库加锁
    使用分布式锁，可以针对某一条数据加锁
    使用synchronized加锁，是对方法加锁，多个请求，key为1的数据会被锁住，key为2的数据的请求也会被锁住
    
    
    实例在redis_practice_2包中