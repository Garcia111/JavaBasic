package com.example.javabasic.reflection;

/**
 * @author：Cheng.
 * @date：Created in 16:41 2019/10/22
 */
public class ReflectionTest {

    //Class包含与类相关的信息，Java使用Class对象来执行其RTI,例如转型这样的操作，每个类都有一个Class对象。
    // 为了生成这个对象，运行这个程序的Java虚拟机将使用"类加载器"子系统。

    //类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器。
    //所有的类都是在对其第一次使用时动态加载到JVM中，当程序创建第一个对类的静态成员引用时，就会加载这个类。
    //这个证明构造器也是类的静态方法，即使在构造器之前没有static关键字。
    // 因此，使用new 操作符创建类的新对象也会被当做对类的静态成员的引用。

    //类加载期首先检查这个类的Class对象是否已经被加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。
    // 在这个类的字节码被加载时，他们会接收验证，以确保其没有被破坏，并且不包含不良Java代码。
    //一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。


    //无论何时，只要你想在运行时使用类型信息，就必须首先获得恰当的Class对象的引用。
    //使用Class.forName()适用于你没有该类的对象，而只是知道该类的完全限定名的情况；
    //如果已经用来了一个类的实例对象，可以通过调用getClass()方法来获取Class引用。

    //当时用 .class来创建对Class对象的引用时，不会自动地初始化该Class对象。
    //为了实用类而做的准备工作实际上包含三个步骤：
    //1.加载---类加载器从classpath指定的路径中加载字节码文件，进行验证，并创建一个Class对象；
    //2.链接---在验证过程中，创建Class文件中的静态域，和对其他类的引用
    //3.初始化----如果存在父类，则调用其父类的静态构造器和静态方法。
}
