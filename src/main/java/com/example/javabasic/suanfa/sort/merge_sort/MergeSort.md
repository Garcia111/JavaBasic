归并排序
    归并 即指将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以先递归地将它分成两半分别排序，
    然后将结果归并起来。
    优点：时间复杂度为O(NlogN)
    缺点：空间复杂度为O(N)

  归并排序算法的使用情景：
    归并排序算法和快速排序算法是Java.util.Arrays中使用的排序算法。
    对一般的基本数据类型，Arrays.sort函数使用双轴快速排序算法；
    而对于对象类型使用归并排序算法，准确的说使用的是TimeSort排序算法，它是归并排序的优化版本；
    这样做有两个原因：
    1.归并排序是稳定的，而快速排序是不稳定的；
    2.对于基本数据类型，排序的稳定性意义不大，但是对于复合数据类型，比如对象，排序的稳定性就能帮助我们保持排序结果的某些性质。


  一般归并排序的思想：
  先将有序子序列放入临时数组，然后设置两个指针依次从两个子序列的开始寻找最小元素放入临时的归并数组中，然后将临时归并数组
  复制到原有数组
  步骤：
    1.创建一个额外的大集合用于存储归并结果，长度是两个小集之和；
    2.从左到右逐一比较两个小集合的元素，把较小的元素优先放入大集合；
    3.从另一个还有剩余元素的集合中，将剩余元素按顺序复制到大集合尾部；


  原地归并
    当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。
    原地归并可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。
    原地归并利用的核心思想是"反转内存"的变体，即"交换两段相邻内存块"，对于反转内存的相关文章
    具体记录：https://www.cnblogs.com/cyxdn/p/12097747.html


  归并排序根据排序的拆分方向又分为自顶向下的归并排序和自底向上的归并排序
  自顶向下的归并排序：
    自顶向下的排序算法就是把数组元素不断的二分，直到子数组的元素个数为一个，因为这个时候子数组必定是有序的，然后将两个有序的序列合并成一个
    新的有序序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。
    以上所说的一般归并排序和原地归并排序都属于自顶向下的归并排序；

  自底向上的归并排序：
    自底向上的归并排序算法就是数组中先一个一个归并成两个元素一组的有序序列，两个元素一组的序列归并成四个元素一组的有序序列，
    然后四个元素一组的有序序列归并成八个元素一组的有序序列，以此类推，直到归并的长度大于整个数组的长度，此时整个数组有序。
    需要注意的是：数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。

  自顶向下的归并排序算法一般用递归来实现，而自底向上的归并排序可以使用循环来实现。
    示例中的自顶向下和自底向上的归并排序使用的都是一般归并排序，需要使用辅助数组，没有使用原地归并排序

  两种方向的归并排序的适用场景：
  1.自底向上的归并排序比较适合用链表组织的数据

     想像一下将链表按照大小为1的链表进行排序，然后是大小为2的子链表，然后是大小为4，这种方法只需要重新组织
     链表就能将链表原地排序，不需要创建任何新的链表节点。

  2.当数组长度为2的幂时，两种方向的归并排序的比较次数和数组访问次数正好相同，只是顺序不同。
    其他时候，这两种方法的比较和数组访问的次序会有所不同。。。。（待实验）











