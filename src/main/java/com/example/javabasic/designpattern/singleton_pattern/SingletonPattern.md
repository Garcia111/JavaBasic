单例模式
    单例模式是最简单的设计模式，这次一定要记住啊~~

  1.应用场景
    有一些对象只需要一个，比方说：线程池，缓存，对话框，日志对象等。

  Java静态变量的缺点：
    如果将对象赋值给一个全局变量，那么你必须在程序一开始就创建好对象，如果这个对象非常耗费资源，
    而在这次执行过程中又一直没有用到它，就会形成浪费。使用单例模式，可以在需要时才会创建对象。


  单例模式要点：
    1.构造方法私有化；
    2.创建一个静态的获取实例的方法；
    3.为了防止多线程情况下创建多个实例，如果直接简单地在getInstance方法上加上synchronized关键字，会导致性能下降
      因为一旦创建了实例，就不再需要同步getInstance()方法，因此如果之后每次调用都进行同步，将是一种累赘。
      【同步一个方法可能会造成程序执行效率下降100倍】
    4.每个类加载器都定义了一个命名空间，如果有两个以上的类加载器，不同的类加载器可能会加载同一个类，从整个程序
        来看，同一个类会被加载多次。所以，如果你的程序有多个类加载器，又同时使用了单例模式，有可能会出现多个单例
        并存的怪异现象，因此此时应该自行指定类加载器，并制定同一个类加载器。

  Spring中的单例模式
    在默认情况下，Spring应用上下文中所有bean都是以单例的形式创建的。不管给定的一个bean被注入到其他bean多少次，
    每次注入的都是同一个实例。

    但是有的时候，你使用的类是易变的，它们会保持一些状态，因此重用是不安全的。这时候就不能再将class声明为单例的bean,
    因为对象会被污染。

    Spring定义了多种作用域，可以用于基于这些作用域创建bean。
    1.单例：singleton,在整个应用中，只创建bean的一个实例，
    2.原型：prototype，每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例；
    3.会话：Session,在web应用中为每个会话创建一个bean实例
    4.请求：request,在web应用中，为每个请求创建一个bean实例。
    5.global session:

    使用@Scope注解指定实例的作用域

    单例在Spring的同一个容器中只会被创建一次，保存在缓存中，后续再获取bean，就直接从单例缓存中获取了。
    当然，这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singletonFacotries中实例化一个新对象。

    对于prototype的bean来说，每次请求来的时候直接实例化新的bean，没有缓存以及从缓存中查的过程

    单例bean的优势：
    1.减少了新生成实例的消耗；
        新生成实例消耗包含两方面：首先Spring会通过反射或者cglib来生成bean实例，这都是消耗性能的操作，其次给对象分配内存也会涉及复杂的算法；
    2.减少jvm垃圾回收；
         由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。
    3.可以快速获取到bean
        因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快

    单例bean的劣势：
        如果这个bean是一个有状态的bean，那么将其设置为单例，则会在并发的情况下出现线程安全问题。


  Spring单例模式与线程安全

        当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，此时就应该注意了
        如果处理逻辑中有对单例实例的状态修改（体现为该单例实例的成员属性的修改），则必须考虑线程同步问题。

        ThreadLocal和线程同步机制都可以解决多线程中相同变量的访问冲突：
          线程同步机制：通过对象的锁保证同一时间只有一个线程访问变量，这时该变量是多个线程共享的，使用同步机制要求程序缜密的分析
                什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。
          ThreadLocal:会为每一个线程提供一个独立的变量副本，隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，
                因此就没有必要再对该变量进行同步了，在编写多线程代码时可以将不安全的变量封装进ThreadLocal。


  【Spring使用ThreadLocal解决线程安全问题】

            在一般情况下，只有无状态的bean才可以在多线程环境下共享。在Spring中，绝大部分Bean都可以声明为singleton作用域，
            就是因为Spring对一些Bean中的非线程安全状态采用了ThreadLocal进行处理，让它们也称为线程安全的状态。

            使用ThreadLocal实例--ConnectionHolder.java：
            例如，我们有一个银行的BankDAO类和一个个人账户的PeopleDAO类，现在需要个人向银行进行转账，在PeopleDAO类中有一个账户减少的方法，
            BankDAO类中有一个账户增加的方法，那么这两个方法在调用的时候必须使用同一个Connection数据库连接对象，
            如果他们使用两个Connection对象，则会开启两段事务，可能出现个人账户减少而银行账户未增加的现象。
            使用同一个Connection对象的话，在应用程序中可能会设置为一个全局的数据库连接对象，从而避免在调用每个方法时都传递一个Connection对象。
            问题是当我们把Connection对象设置为全局变量时，你不能保证是否有其他线程会将这个Connection对象关闭，这样就会出现线程安全问题。
            解决办法就是在进行转账操作这个线程中，使用ThreadLocal中获取Connection对象。
            这样，在调用个人账户减少和银行账户增加的线程中，就能从ThreadLocal中取到同一个Connection对象，并且这个Connection对象为转账操作这个线程独有，不会被其他线程影响，保证了线程安全性。



            **之前就见过下面这句话，但是现在才稍微理解了**
                一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑。下层通过接口向上层开放功能调用。
                在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程ThreadLocal是解决线程安全问题一个很好的思路，
                它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
                在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。



            线程安全问题都是由全局变量及静态变量引起的。
                若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；
                若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

                （1）常量只存在读操作，始终是线程安全的；
                （2）每次调用方法前都新建一个的实例是线程安全的，因为不会访问共享资源；
                （3）局部变量都是线程安全的，因为每执行一个犯法，都坏在独立的空间创建局部变量，它不是共享的资源。
                    局部变量包括方法的参数变量和方法内变量。


到底什么是有状态bean,什么是无状态bean
    常说Spring中有状态的bean是线程不安全的，多线程访问需要进行并发处理；无状态的bean是线程安全的，
    那么到底什么是有状态bean,什么是无状态bean？

    1.有状态：就是有数据存储功能，有状态对象，就是实例变量的对象，可以保存数据，是非线程安全的。
            在不同的方法调用间不保留任何状态；

    2.无状态：就是一次操作，不能保存数据。无状态对象就是没有实例变量的对象，不能保存数据，是不可变的类，是线程安全的。


    对比我看了下自己经常编写的代码，controller service 包括dao层一般都是无状态的bean，难怪自己平时处理不到多线程并发操作。

    无状态的bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。
    有状态的bean，在多线程环境下不安全，适合Prototype模式。

    Struts2中的Action经常会包含一些可以存储数据的实例对象，是有状态信息的，在多线程环境下是不安全的，因此Struts2默认的是实现
    Prototype模式，在Spring中，Struts2的Action中，scope要配置成prototype模式。