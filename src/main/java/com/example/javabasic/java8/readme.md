Java8新特性：

**_`****_1.接口默认方法_**（示例：default_method_interface）**`_**
    
    默认方法与抽象方法的不同之处在于抽象方法必须要求接口的实现类实现该抽象方法，但是默认方法没有这个要求。
    默认方法要求接口必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它，如果有必要的话可以覆盖这个默认实现。

    接口与抽象类的区别：
    1.接口要被实现，抽象类要被继承 ---pass
    2.接口只能做方法声明，抽象类中可以做方法声明，也可以做方法实现------注意：此条区别不再适用
    3.接口里面定义的变量只能是公共的静态常量，抽象类中的变量是普通常量；
    4.接口是设计的结果，抽象类是重构的结果；
    5.抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别更高。
    6.抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量-----注意：此条不再适用；
    7.抽象类主要用来抽象类别，接口主要用来抽象功能。

    _`接口默认方法多重继承的冲突说明：`_
        
        由于接口提供了默认的方法实现，当一个类实现了多个接口，如果这些接口中有同名的默认方法，会有冲突现象发生。
        发生冲突时，规则如下：
       1.一个声明在类里面的方法优先于任何默认的方法；
       2.优先选取最具体的实现，eg: 接口B 集成接口A， 并且B接口中对A接口中的默认方法进行了覆盖，此时同时集成接口 A B 会优先集成B中的默认方法；


  
    接口默认方法不能重载Object类的任何方法；每一个Java类都是Object的子类，在类的接口上包含这些默认方法
    是没有意义的，它们也从来不会被编译。
  
    在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。
    默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。
    尽管默认方法非常强大，但是在使用默认方法时我们需要仔细思考是不是真的有必要使用默认方法。
  
  
**_`2.接口静态方法（static_interface_method包）`_**
        
        Java8中接口可以声明静态方法，在接口中定义静态方法，使用static关键字。
        
  继承多个接口其中的静态方法会冲突吗？
    
    Java支持一个实现类可以实现多个接口，如果有两个接口中的静态方法一模一样，并且一个实现类
    同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态
    方法，所以对编译器来说是可以区分开的。
    也就是说调用接口中的静态方法的方式是  接口1.静态方法名；接口2.静态方法名
    所以是可以区分开的。


3.Lambda表达式
    
    Lambda表达式允许把函数作为一个方法的参数，即行为参数化，函数作为参数传递进方法中。
    
4.函数式接口(好厉害)  使用@FunctionalInterface注解声明函数式接口
    
    函数式接口是指仅仅只包含一个抽象方法的接口。
    
    Lambda表达式是如何在Java的类型系统中表示的呢？
    每一个Lambda表达式都对应一个类型，通常是接口类型。函数式接口是仅仅只是包含一个抽象方法的接口。
    每一个该类型的Lambda表达式都会被匹配到这个抽象方法。
    因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。


5.方法引用

    在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。
    Arrays.sort(strArray,(s1,s2)->s1.compareToIgnoreCase(s2));
    
    在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。
    Arrays.sort(strArray,String::compareToIgnoreCase);
    
    方法引用是永爱直接访问类或者实力的已经存在的方法或者构造方法。
    方法引用的标准形式是：类名::方法名，有以下四种形式的方法引用
    
    1.引用静态方法  ContainingClass:: staticMethodName
    2.引用某个对象的实例方法 containingObject::instanceMethodName
    3.引用某个类型的任意对象的实力方法：ContainingType::methodName
    4.引用构造方法: ClassName::new    
  






