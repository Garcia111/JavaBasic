Java8新特性：

**_`****_1.接口默认方法_**（示例：default_method_interface）**`_**
    
    默认方法与抽象方法的不同之处在于抽象方法必须要求接口的实现类实现该抽象方法，但是默认方法没有这个要求。
    默认方法要求接口必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它，如果有必要的话可以覆盖这个默认实现。

    接口与抽象类的区别：
    1.接口要被实现，抽象类要被继承 ---pass
    2.接口只能做方法声明，抽象类中可以做方法声明，也可以做方法实现------注意：此条区别不再适用
    3.接口里面定义的变量只能是公共的静态常量，抽象类中的变量是普通常量；
    4.接口是设计的结果，抽象类是重构的结果；
    5.抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别更高。
    6.抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量-----注意：此条不再适用；
    7.抽象类主要用来抽象类别，接口主要用来抽象功能。

    _`接口默认方法多重继承的冲突说明：`_
        
        由于接口提供了默认的方法实现，当一个类实现了多个接口，如果这些接口中有同名的默认方法，会有冲突现象发生。
        发生冲突时，规则如下：
       1.一个声明在类里面的方法优先于任何默认的方法；
       2.优先选取最具体的实现，eg: 接口B 集成接口A， 并且B接口中对A接口中的默认方法进行了覆盖，此时同时集成接口 A B 会优先集成B中的默认方法；


  
    接口默认方法不能重载Object类的任何方法；每一个Java类都是Object的子类，在类的接口上包含这些默认方法
    是没有意义的，它们也从来不会被编译。
  
    在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。
    默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。
    尽管默认方法非常强大，但是在使用默认方法时我们需要仔细思考是不是真的有必要使用默认方法。
  
  
**_`2.接口静态方法（static_interface_method包）`_**
        
        Java8中接口可以声明静态方法，在接口中定义静态方法，使用static关键字。
        
  继承多个接口其中的静态方法会冲突吗？
    
    Java支持一个实现类可以实现多个接口，如果有两个接口中的静态方法一模一样，并且一个实现类
    同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态
    方法，所以对编译器来说是可以区分开的。
    也就是说调用接口中的静态方法的方式是  接口1.静态方法名；接口2.静态方法名
    所以是可以区分开的。


3.Lambda表达式
    
    Lambda表达式允许把函数作为一个方法的参数，即行为参数化，函数作为参数传递进方法中。
    
4.函数式接口(好厉害)  使用@FunctionalInterface注解声明函数式接口
    
    函数式接口是指仅仅只包含一个抽象方法的接口。
    
    Lambda表达式是如何在Java的类型系统中表示的呢？
    每一个Lambda表达式都对应一个类型，通常是接口类型。函数式接口是仅仅只是包含一个抽象方法的接口。
    每一个该类型的Lambda表达式都会被匹配到这个抽象方法。
    因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。


5.方法引用

    在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。
    Arrays.sort(strArray,(s1,s2)->s1.compareToIgnoreCase(s2));
    
    在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。
    Arrays.sort(strArray,String::compareToIgnoreCase);
    
    方法引用是永爱直接访问类或者实力的已经存在的方法或者构造方法。
    方法引用的标准形式是：类名::方法名，有以下四种形式的方法引用
    
    1.引用静态方法  ContainingClass:: staticMethodName
    2.引用某个对象的实例方法 containingObject::instanceMethodName
    3.引用某个类型的任意对象的实力方法：ContainingType::methodName
    4.引用构造方法: ClassName::new    
  
6.Stream

    Java8中添加的Stream API，将真正的函数式变成风格引入到Java中。流可以是无限的，有状态的，可以是顺序的，也可以是并行的
    在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。
    中间操作包括：filter map  flatmap peel  distinct  sorted  limit 和substream
    中止操作包括: forEach  toArray  reduce  collect  min  max  count  anyMatch  allMatch
    noneMatch  findFirst  findAny

    https://blog.csdn.net/icarusliu/article/details/79495534
    Java8中的函数式接口：
        1.Consumer:
            Consumer的意思就是消费，即针对某个东西我们来使用它，因此它包含有一个有输入而无输出的accept接口方法
            接口默认方法：andThen----用来指定执行完当前consumer对象的accept方法后，接下来执行哪一个consumer对象的accept方法；

        2.Function 函数式编程接口：
            函数经常是有输入输出的，因此它含有一个apply方法，包含一个输入输出

    1.一些重要方法说明：
    http://blog.csdn.net/icarusliu/article/details/79495534
    stream: 返回数据流，集合作为其源
    parallelStream: 返回并行数据流， 集合作为其源
    filter: 方法用于过滤出满足条件的元素
    map: 方法用于映射每个元素对应的结果
    forEach: 方法遍历该流中的每个元素
    limit: 方法用于减少流的大小
    sorted: 方法用来对流中的元素进行排序
    anyMatch: 是否存在任意一个元素满足条件（返回布尔值）
    allMatch: 是否所有元素都满足条件（返回布尔值）
    noneMatch: 是否所有元素都不满足条件（返回布尔值）
    collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束

    BiFunction
    是一个函数式接口，包含的函数式方法定义如下

















