多态
  多态中的方法调用绑定
 1.多态即在方法调用过程中将一个类的对象向上转型为其基类类型的引用，编译器在运行时根据对象的类型对调用方法的主体进行
    绑定，这称为后期绑定，也称为动态绑定或者运行时绑定，Java中所有方法都是通过动态绑定实现多态的。

 2.在多态中，只有非private方法才可以被覆盖，如果你覆盖了private方法，编译器不会报错，但是调用指向父类的引用的某个private方法时
  并不会自动执行某个子类的private覆盖方法。

 3.【当子类对象向上转型为基类引用时，任何域访问操作都在编译期解析而不是运行时动态绑定的，因此不是多态的。】实例见FieldAccess.java
    编译器为Super.field和Sub.field分配了不同的存储空间，Sub类实际上包含两个称为field的域，它自己和通Super处继承的。

    如果一个对象引用最终指向的是基类，则使用该引用访问域，得到的是基类的域；
    如果一个对象引用最终指向的是子类，则使用该引用访问域，得到的是子类的域；

 4.如果某个方法是静态的，它的行为就不具有多态性，因为静态方法是与类，而不是与单个对象相关联的。
     示例:StaticPolymorphism.java


 5.构造器和多态
    构造器并不具有多态性，它们实际上是static方法，只不过static声明是隐式的。
    基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。
    构造器具有一项特殊任务：检查对象是否被正确地构造，子类只能访问它自己的成员，因为一般父类的成员都会设置为private类型。
    只有基类的构造器才具有恰当的只是和权限对自己的元素进行初始化。因此，必须令所有的构造器都得到调用，否则就不可能正确构建完整对象。

   调用某一导出个类的构造器时，该类与其基类链的调用顺序：
   1）调用基类的构造器，从最高层级的基类的构造器开始，逐级向下调用，直到最底层的导出类；
   2）按声明顺序调用成员的初始化方法；
   3）调用到处类构造器的主体；

    示例见Sandwich.java

  继承与清理
    通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收期进行处理。
    如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法。
    如果一个子类对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反，首先清理子类，然后才是基类。
    这是因为子类的清理可能会调用基类中的某些方法，所以需要使基类中的构件其作用而不应过早地销毁它们。
    对于类中的变量，销毁顺序则应该与声明的顺序相反。

   如果某个成员对象A被多个其他的对象共享，必须使用引用计数来跟踪仍然持有对象A的对象的数量，只有当该计数
    为0，也就是没有对象持有成员对象A的引用的时候，才能够清理成员对象A。 示例见：ReferenceCounting.java


 构造器内部的多态方法的行为
  在一般的方法内部，动态绑定的调用是在运行时才决定的，因为对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。
  如果要在父类的构造器内部调用一个动态绑定的方法，则初始化子类对象时，会调用该父类的构造方法，执行到该动态绑定的方法时
  会调用子类中的覆盖方法，这时，这个调用的效果是难以预料的，因为这个调用是发生在子类对象的构造过程中的，子类对象还没有构造
  完成，就要调用此子类对象的方法了。这可能会造成一些难以发现的隐藏错误。





















