多态
  多态中的方法调用绑定
 1.多态即在方法调用过程中将一个类的对象向上转型为其基类类型的引用，编译器在运行时根据对象的类型对调用方法的主体进行
    绑定，这称为后期绑定，也称为动态绑定或者运行时绑定，Java中所有方法都是通过动态绑定实现多态的。

 2.**在多态中，只有非private方法才可以被覆盖**，如果你覆盖了private方法，编译器不会报错，但是调用指向父类的引用的某个private方法时
  并不会自动执行某个子类的private覆盖方法。

 3.【**当子类对象向上转型为基类引用时，任何域访问操作都在编译期解析而不是运行时动态绑定的，因此不是多态的。**】实例见FieldAccess.java
    编译器为Super.field和Sub.field分配了不同的存储空间，Sub类实际上包含两个称为field的域，它自己和通Super处继承的。

    如果一个对象引用最终指向的是基类，则使用该引用访问域，得到的是基类的域；
    如果一个对象引用最终指向的是子类，则使用该引用访问域，得到的是子类的域；

 4.**如果某个方法是静态的，它的行为就不具有多态性，因为静态方法是与类，而不是与单个对象相关联的。**
     示例:StaticPolymorphism.java


 5.构造器和多态
    **构造器并不具有多态性，它们实际上是static方法，只不过static声明是隐式的**。
    基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。
    构造器具有一项特殊任务：检查对象是否被正确地构造，子类只能访问它自己的成员，因为一般父类的成员都会设置为private类型。
    只有基类的构造器才具有恰当的只是和权限对自己的元素进行初始化。因此，必须令所有的构造器都得到调用，否则就不可能正确构建完整对象。

   调用某一导出个类的构造器时，该类与其基类链的调用顺序：
   1）调用基类的构造器，从最高层级的基类的构造器开始，逐级向下调用，直到最底层的导出类；
   2）按声明顺序调用成员的初始化方法；
   3）调用到处类构造器的主体；

    示例见Sandwich.java

  【**继承与清理**】
    通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收期进行处理。
    如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法。
    **如果一个子类对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反，首先清理子类，然后才是基类**。
    这是因为子类的清理可能会调用基类中的某些方法，所以需要使基类中的构件其作用而不应过早地销毁它们。
    **对于类中的变量，销毁顺序则应该与声明的顺序相反**。

   **如果某个成员对象A被多个其他的对象共享，必须使用引用计数来跟踪仍然持有对象A的对象的数量，只有当该计数
    为0，也就是没有对象持有成员对象A的引用的时候，才能够清理成员对象A。** 示例见：ReferenceCounting.java


 【构造器内部的多态方法的行为】
  **note**:在一般的方法内部，动态绑定的调用是在运行时才决定的，因为对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。
  如果要在父类的构造器内部调用一个动态绑定的方法，则初始化子类对象时，会调用该父类的构造方法，执行到该动态绑定的方法时
  会调用子类中的覆盖方法，这时，因为这个调用是发生在子类对象的构造过程中的，子类对象还没有构造完成，就要调用此子类对象的方法了。
  这可能会造成一些难以发现的隐藏错误。

    在编写构造器时有一条有效的准则："用尽可能简单的方法使对象进入正常状态，如果可以的话，在构造器内避免调用其他方法"
    在构造器内唯一能够安全调用的那些方法是基类中的final方法和private方法，因为这些方法都不可能被覆盖，因此也就不会出现上述问题。
    示例见PolyConstructors.java

  初始化的实际过程是：
    1）在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零；
    2）调用初始化对象所属类的构造器，如果存在基类要先调用基类的构造器，如果基类中存在动态绑定方法，则会调用子类中的覆盖方法；
    3）按照声明的顺序调用成员的初始化方法。
    4）调用到处类的构造器主体。


  6.协变返回类型
    Java SE5 与Java较早版本之间的主要差异就是较早的版本在子类的覆盖方法中，不允许返回父类中原方法返回类型的
    导出类，而必须返回原类型。

  7.在使用现有的类来建立新类时，如果首先考虑使用继承技术，会加重设计负担。更好的方式是首先选择"组合"，尤其是不能十分确定
   应该使用哪一种方式时。组合不会强制我们的程序设计进入继承的层次结构中。
   组合更加灵活，因为它可以动态选择类型，相反，继承在编译时就需要知道确切的类型。
   示例见：Transmogrify.java

   一条通用的准则是："**用继承表达行为间的差异，并用字段表达状态上的变化**"。例如，在Transmogrify.java中，通过继承
   得到了两个不同的类，用于表达act()行为上的差异，而Stage通过运用组合使自己的状态发生了变化










