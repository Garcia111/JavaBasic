多态
  多态中的方法调用绑定
 1.多态即在方法调用过程中将一个类的对象向上转型为其基类类型的引用，编译器在运行时根据对象的类型对调用方法的主体进行
    绑定，这称为后期绑定，也称为动态绑定或者运行时绑定，Java中所有方法都是通过动态绑定实现多态的。

 2.在多态中，只有非private方法才可以被覆盖，如果你覆盖了private方法，编译器不会报错，但是调用指向父类的引用的某个private方法时
  并不会自动执行某个子类的private覆盖方法。

 3.【当子类对象向上转型为基类引用时，任何域访问操作都在编译期解析而不是运行时动态绑定的，因此不是多态的。】实例见FieldAccess.java
    编译器为Super.field和Sub.field分配了不同的存储空间，Sub类实际上包含两个称为field的域，它自己和通Super处继承的。

    如果一个对象引用最终指向的是基类，则使用该引用访问域，得到的是基类的域；
    如果一个对象引用最终指向的是子类，则使用该引用访问域，得到的是子类的域；

 4.如果某个方法是静态的，它的行为就不具有多态性，因为静态方法是与类，而不是与单个对象相关联的。
     示例:StaticPolymorphism.java


 5.构造器和多态
    构造器并不具有多态性，它们实际上是static方法，只不过static声明是隐式的。
    基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。
    构造器具有一项特殊任务：检查对象是否被正确地构造，子类只能访问它自己的成员，因为一般父类的成员都会设置为private类型。
    只有基类的构造器才具有恰当的只是和权限对自己的元素进行初始化。因此，必须令所有的构造器都得到调用，否则就不可能正确构建完整对象。

   调用某一导出个类的构造器时，该类与其基类链的调用顺序：
   1）调用基类的构造器，从最高层级的基类的构造器开始，逐级向下调用，直到最底层的导出类；
   2）按声明顺序调用成员的初始化方法；
   3）调用到处类构造器的主体；

    示例见Sandwich.java

  继承与清理
    通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收期进行处理。
    如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法。



















